<?
//
// $Id$ */
//
function ReadDump
   (
   $db_link,
   $sql_query,
   $bpn,
   $allow_dynamic_sorting = '1',
   $mode = "",
   $be_viewable_result = "TRUE",
   $be_drill_down_available = 'TRUE',
   $table_border = 0,
   $cell_padding = 3,
   $max_text_field_display_len = 64,
   $is_js_confirmed = "0",
   $lang = "en",
   $server = "1",
   $pos = "0",
   $goto = "form-analyze.phtml",
   $zero_rows = "None found.",
   $prev_sql_query = ""
   )
{
/**
 * Removes comment lines and splits up large sql files into individual queries
 *
 * Last revision: September 23, 2001 - gandon
 *
 * @param   array    the splitted sql commands
 * @param   string   the sql commands
 * @param   integer  the MySQL release number (because certains php3 versions
 *                   can't get the value of a constant from within a function)
 *
 * @return  boolean  always true
 *
 * @access  public
 */
function PMA_splitSqlFile(&$ret, $sql)
{
    $sql          = trim($sql);
    $sql_len      = strlen($sql);
    $char         = '';
    $string_start = '';
    $in_string    = FALSE;

    for ($i = 0; $i < $sql_len; ++$i) {
        $char = $sql[$i];
        // We are in a string, check for not escaped end of strings except for
        // backquotes that can't be escaped
        if ($in_string) {
            for (;;) {
                $i         = strpos($sql, $string_start, $i);
                // No end of string found -> add the current substring to the
                // returned array
                if (!$i) {
                    array_push($ret[],$sql);
                    return TRUE;
                }
                // Backquotes or no backslashes before quotes: it's indeed the
                // end of the string -> exit the loop
                else if ($string_start == '`' || $sql[$i-1] != '\\') {
                    $string_start      = '';
                    $in_string         = FALSE;
                    break;
                }
                // one or more Backslashes before the presumed end of string...
                else {
                    // ... first checks for escaped backslashes
                    $j                     = 2;
                    $escaped_backslash     = FALSE;
                    while ($i-$j > 0 && $sql[$i-$j] == '\\') {
                        $escaped_backslash = !$escaped_backslash;
                        $j++;
                    }
                    // ... if escaped backslashes: it's really the end of the
                    // string -> exit the loop
                    if ($escaped_backslash) {
                        $string_start  = '';
                        $in_string     = FALSE;
                        break;
                    }
                    // ... else loop
                    else {
                        $i++;
                    }
                } // end if...elseif...else
            } // end for
        } // end if (in string)

        // We are not in a string, first check for delimiter...
        else if ($char == ';') {
            // if delimiter found, add the parsed part to the returned array
            array_push($ret[],substr($sql, 0, $i));
            $sql        = ltrim(substr($sql, min($i + 1, $sql_len)));
            $sql_len    = strlen($sql);
            if ($sql_len) {
                $i      = -1;
            } else {
                // The submited statement(s) end(s) here
                return TRUE;
            }
        } // end else if (is delimiter)

        // ... then check for start of a string,...
        else if (($char == '"') || ($char == '\'') || ($char == '`')) {
            $in_string    = TRUE;
            $string_start = $char;
        } // end else if (is start of string)

        // ... for start of a comment (and remove this comment if found)...
        else if ($char == '#'
                 || ($char == ' ' && $i > 1 && $sql[$i-2] . $sql[$i-1] == '--')) {
            // starting position of the comment depends on the comment type
            $start_of_comment = (($sql[$i] == '#') ? $i : $i-2);
            // if no "\n" exits in the remaining string, checks for "\r"
            // (Mac eol style)
            $end_of_comment   = (strpos(' ' . $sql, "\012", $i+2))
                              ? strpos(' ' . $sql, "\012", $i+2)
                              : strpos(' ' . $sql, "\015", $i+2);
            if (!$end_of_comment) {
                // no eol found after '#', add the parsed part to the returned
                // array if required and exit
                if ($start_of_comment > 0) {
                    array_push($ret[],trim(substr($sql, 0, $start_of_comment)));
                }
                return TRUE;
            } else {
                $sql          = substr($sql, 0, $start_of_comment)
                              . ltrim(substr($sql, $end_of_comment));
                $sql_len      = strlen($sql);
                $i--;
            } // end if...else
        } // end else if (is comment)

    } // end for

    // add any rest to the returned array
    if (!empty($sql)) {
        array_push($ret[],$sql);
    }
    return TRUE;
} // end of the 'PMA_splitSqlFile()' function


function ExecSelect
   (
   $db_link,
   $select_statement,
   $bpn,
   $lang,
   $server,
   $zero_rows,
   $mode,
   $goto,
   $table_border,
   $cell_padding,
   $max_text_field_display_len,
   $allow_dynamic_sorting = '1',
   $row_action_designator = 'urnn00000'  // send 'nnnn00000' to preserve header/data column alignment if no drill-down will be available
   )
   {
   // ViewQuery will stripslash the query if get_magic_quotes_gpc
   if (get_magic_quotes_gpc() == 1)
      {
      $sql_query = addslashes($select_statement);
      }
   else
      {
      $sql_query = $select_statement;
      }
   require_once('f_viewquery.phtml');
   ViewQuery
      (
      $db_link,
      $bpn,
      $sql_query,
      $lang,
      $server,
      $zero_rows,
      ($mode . $goto),
      $table_border,
      $cell_padding,
      $max_text_field_display_len,
      $mode,
      $row_action_designator
      );
   }


    $pieces       = array();
    PMA_splitSqlFile($pieces, $sql_query);
    $pieces_count = count($pieces);

    // Only one query to run
    if ($pieces_count == 1 && !empty($pieces[0]) && ($be_viewable_result == 'TRUE'))
       {
       ExecSelect
          (
          $db_link,
          $pieces[0],
          $bpn,
          $lang,
          $server,
          $zero_rows,
          $mode,
          $goto,
          $table_border,
          $cell_padding,
          $max_text_field_display_len,
          $allow_dynamic_sorting,
          ($be_drill_down_available == 'TRUE' ? 'urnn00000' : 'nnnn00000') // for row_action_designator
          );
       }

    // Runs multiple queries
    else {
        for ($i = 0; $i < $pieces_count; $i++) {
            $a_sql_query = $pieces[$i];
            //
            if (($i < ($pieces_count - 1)) or ($be_viewable_result == 'FALSE'))
               {
               $result = $db_link->query($a_sql_query);
               if ($result == FALSE)
                  { // readdump failed
                  $my_die = $a_sql_query;
                  break;
                  }
               if (!isset($reload) && preg_match('/^(DROP|CREATE)[[:space:]]+(IF EXISTS[[:space:]]+)?(TABLE|DATABASE)[[:space:]]+(.+)/i', $a_sql_query))
                  {
                  $reload = 1;
                  }
               }
            else
               {
               //
               // This is the last statement of the script, and we are assuming it is a SELECT.
               //
               ExecSelect
                  (
                  $db_link,
                  $a_sql_query,
                  $bpn,
                  $lang,
                  $server,
                  $zero_rows,
                  $mode,
                  $goto,
                  $table_border,
                  $cell_padding,
                  $max_text_field_display_len,
                  $allow_dynamic_sorting,
                  ($be_drill_down_available == 'TRUE' ? 'urnn00000' : 'nnnn00000') // for row_action_designator
                  );
               exit();
               }
        } // end for
    } // end else if
    unset($pieces);
}
?>
